%{
    #include "ast.h"    // Ensure ast.h has Num (for int) and RealLit (for real) classes
    #include "parser.h" // Generated by Bison; will need new token definitions
    #include <iostream>
    #include <string>
    #include <cstdlib>   // For atoi, atof

    // For isatty/fileno on MinGW if %option never-interactive isn't enough
    #include <cstdio>
    #include <io.h>

    // Global line and column numbers, 1-indexed.
    // These store the starting position of the current token.
    // parser.y should declare: extern int lin; extern int col;
    int lin = 1;
    int col = 1;

    // For tracking the start of a multi-line comment for error messages
    int comment_start_lin = 0;
    int comment_start_col = 0;

    // Forward declaration for yyerror if not implicitly handled by parser.h
    // extern int yyerror(const char *s);
%}

%option caseless noyywrap nounistd never-interactive stack

/* Start condition for multi-line comments */
%x ML_COMMENT

DIGIT    [0-9]
ALPHA    [a-zA-Z]
/* ID_CHAR is effectively ALPHA | DIGIT | _ */

%%

<INITIAL>{
    /* Whitespace - updates position for the *next* potential token */
    [ \t]+              { col += yyleng; }
    \r\n|\n|\r         { lin++; col = 1; }

    /* Comments */
    "//"[^\n\r]* {  col += yyleng; /* Single line comment, ignore. Position advanced by trailing newline or next token. */
                          /* For robustness if no newline, explicitly advance: col += yyleng; */
                        }
    "{"                 {
                          comment_start_lin = lin;
                          comment_start_col = col; // Record start of '{'
                          col += yyleng;           // Advance past '{'
                          BEGIN(ML_COMMENT);
                        }
    /* Quotes */
    \'([^'\n\\]|\\.)*\'   { 
                        /* Extract the string content (without outer quotes) */
                        /* Potentially handle escape sequences like \' or \\ */
                        /* Store it in yylval.str_val (you have char* str_val in your union) */
                        /* For example: */
                        int len = yyleng - 2; /* Length without quotes */
                        char* s = (char*)malloc(len + 1);
                        strncpy(s, yytext + 1, len);
                        s[len] = '\0';
                        /* Further processing for escapes if needed */
                        yylval.str_val = s; 
                        return STRING_LITERAL; 
                      }

    /* Keywords */
    "program"           { int token_col = col; col += yyleng; return PROGRAM; }
    "var"               { int token_col = col; col += yyleng; return VAR; }
    "integer"           { int token_col = col; col += yyleng; return INTEGER_TYPE; }
    "real"              { int token_col = col; col += yyleng; return REAL_TYPE; }
    "function"          { int token_col = col; col += yyleng; return FUNCTION; }
    "procedure"         { int token_col = col; col += yyleng; return PROCEDURE; }
    "while"             { int token_col = col; col += yyleng; return WHILE; }
    "do"                { int token_col = col; col += yyleng; return DO; }
    "begin"             { int token_col = col; col += yyleng; return BEGIN_TOKEN; }
    "end"               { int token_col = col; col += yyleng; return END_TOKEN; }
    "if"                { int token_col = col; col += yyleng; return IF; }
    "then"              { int token_col = col; col += yyleng; return THEN; }
    "else"              { int token_col = col; col += yyleng; return ELSE; }
    "array"             { int token_col = col; col += yyleng; return ARRAY; }
    "of"                { int token_col = col; col += yyleng; return OF; }
    "div"               { int token_col = col; col += yyleng; return DIV_OP; }
    "not"               { int token_col = col; col += yyleng; return NOT_OP; }
    "or"                { int token_col = col; col += yyleng; return OR_OP; }
    "and"               { int token_col = col; col += yyleng; return AND_OP; }
    "boolean" { /* int token_col = col; */ col += yyleng; return BOOLEAN_TYPE; }
    "true"    { /* int token_col = col; */ col += yyleng; return TRUE_KEYWORD; }
    "false"   { /* int token_col = col; */ col += yyleng; return FALSE_KEYWORD; }
    ".."      { /* int token_col = col; */ col += yyleng; return DOTDOT; }

    /* Literals: Order for Flex to pick longest match.
       Combined real number rules first, then integer. */
    {DIGIT}+\.{DIGIT}*([eE][-+]?{DIGIT}+)? |
        \.{DIGIT}+([eE][-+]?{DIGIT}+)? |
        {DIGIT}+[eE][-+]?{DIGIT}+ {
        yylval.rawRealLit = new RealLit(atof(yytext), lin, col); // NEW: rawRealLit
        col += yyleng;
        return REAL_LITERAL;
    }

    {DIGIT}+ {
        yylval.rawNum = new Num(atoi(yytext), lin, col); // NEW: rawNum
        col+= yyleng;
        return NUM; 
    }

    ({ALPHA}|_)({ALPHA}|{DIGIT}|_)* {
        yylval.rawIdent = new Ident(std::string(yytext), lin, col); // NEW: rawIdent
        col += yyleng;
        return IDENT;
    }

    /* Operators and Punctuation */
    ":="                    { int token_col = col; col += yyleng; return ASSIGN_OP; }
    "<>"                    { int token_col = col; col += yyleng; return NEQ_OP; }
    "<="                    { int token_col = col; col += yyleng; return LTE_OP; }
    ">="                    { int token_col = col; col += yyleng; return GTE_OP; }
    "+"                     { int token_col = col; col += yyleng; return '+'; }
    "-"                     { int token_col = col; col += yyleng; return '-'; }
    "*"                     { int token_col = col; col += yyleng; return '*'; }
    "/"                     { int token_col = col; col += yyleng; return '/'; } /* Real division */
    "="                     { int token_col = col; col += yyleng; return EQ_OP; } /* Equality */
    "<"                     { int token_col = col; col += yyleng; return LT_OP; }
    ">"                     { int token_col = col; col += yyleng; return GT_OP; }
    "("                     { int token_col = col; col += yyleng; return '('; }
    ")"                     { int token_col = col; col += yyleng; return ')'; }
    "["                     { int token_col = col; col += yyleng; return '['; }
    "]"                     { int token_col = col; col += yyleng; return ']'; }
    ":"                     { int token_col = col; col += yyleng; return ':'; }
    ";"                     { int token_col = col; col += yyleng; return ';'; }
    ","                     { int token_col = col; col += yyleng; return ','; }
    "."                     { int token_col = col; col += yyleng; return '.'; }


    .                       {
                            std::cerr << "Lexical Error: Unexpected character '" << *yytext
                                      << "' at line " << lin << ", column " << col << std::endl;
                            col += yyleng;
                            }
}

<ML_COMMENT>{
    "}"                 { col += yyleng; BEGIN(INITIAL); }
    [^{}\n\r]+          { col += yyleng; }
    \r\n|\n|\r         { lin++; col = 1; }
    "{"                 {
                          std::cerr << "Warning: Nested multi-line comment opening '{' found at line "
                                    << lin << ", column " << col
                                    << ". MiniPascal typically does not support true nesting." << std::endl;
                          col += yyleng;
                        }
    <<EOF>>             {
                          std::cerr << "Lexical Error: Unterminated multi-line comment that started at line "
                                    << comment_start_lin << ", column " << comment_start_col << "!" << std::endl;
                          BEGIN(INITIAL);
                          yyterminate();
                        }
}

%%
/* C code section */
/* %option noyywrap means yywrap() is not needed by Flex. */
/* Your main() is in program.cpp */