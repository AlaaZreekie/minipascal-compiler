%{
    #include "ast.h"    // Ensure ast.h has Num (for int) and RealLit (for real) classes
    #include "parser.h" // Generated by Bison; will need new token definitions
    #include <iostream>
    #include <string>
    #include <cstdlib>   // For atoi, atof

    // For isatty/fileno on MinGW if %option never-interactive isn't enough
    #include <cstdio>
    #include <io.h>

    // Global line and column numbers, 1-indexed.
    // These store the starting position of the current token.
    // parser.y should declare: extern int lin; extern int col;
    int lin = 1;
    int col = 1;

    // For tracking the start of a multi-line comment for error messages
    int comment_start_lin = 0;
    int comment_start_col = 0;

    // Forward declaration for yyerror if not implicitly handled by parser.h
    // extern int yyerror(const char *s);
%}

%option caseless noyywrap nounistd never-interactive stack

/* Start condition for multi-line comments */
%x ML_COMMENT

DIGIT    [0-9]
ALPHA    [a-zA-Z]
/* ID_CHAR is effectively ALPHA | DIGIT | _ */

%%

<INITIAL>{
    /* Whitespace - updates position for the *next* potential token */
    [ \t]+              { col += yyleng; }
    \r\n|\n|\r         { lin++; col = 1; }

    /* Comments */
    "//"[^\n\r]* {  col += yyleng; /* Single line comment, ignore. Position advanced by trailing newline or next token. */
                          /* For robustness if no newline, explicitly advance: col += yyleng; */
                        }
    "{"                 {
                          comment_start_lin = lin;
                          comment_start_col = col; // Record start of '{'
                          col += yyleng;           // Advance past '{'
                          BEGIN(ML_COMMENT);
                        }

    /* Keywords */
    "program"           { int token_col = col; col += yyleng; return PROGRAM; }
    "var"               { int token_col = col; col += yyleng; return VAR; }
    "integer"           { int token_col = col; col += yyleng; return INTEGER_TYPE; }
    "real"              { int token_col = col; col += yyleng; return REAL_TYPE; }
    "function"          { int token_col = col; col += yyleng; return FUNCTION; }
    "procedure"         { int token_col = col; col += yyleng; return PROCEDURE; }
    "while"             { int token_col = col; col += yyleng; return WHILE; }
    "do"                { int token_col = col; col += yyleng; return DO; }
    "begin"             { int token_col = col; col += yyleng; return BEGIN_TOKEN; }
    "end"               { int token_col = col; col += yyleng; return END_TOKEN; }
    "if"                { int token_col = col; col += yyleng; return IF; }
    "then"              { int token_col = col; col += yyleng; return THEN; }
    "else"              { int token_col = col; col += yyleng; return ELSE; }
    "array"             { int token_col = col; col += yyleng; return ARRAY; }
    "of"                { int token_col = col; col += yyleng; return OF; }
    "div"               { int token_col = col; col += yyleng; return DIV_OP; }
    "not"               { int token_col = col; col += yyleng; return NOT_OP; }
    "or"                { int token_col = col; col += yyleng; return OR_OP; }
    "and"               { int token_col = col; col += yyleng; return AND_OP; }

    /* Literals: Order for Flex to pick longest match.
       Combined real number rules first, then integer. */
    {DIGIT}+\.{DIGIT}*([eE][-+]?{DIGIT}+)? |
    \.{DIGIT}+([eE][-+]?{DIGIT}+)? |
    {DIGIT}+[eE][-+]?{DIGIT}+ {
                            yylval.realLit = new RealLit(atof(yytext), lin, col);
                            col += yyleng;
                            return REAL_LITERAL;
                        }

    {DIGIT}+                {
                            yylval.tNum = new Num(atoi(yytext), lin, col); // Using your existing Num for integers
                            col += yyleng;
                            return NUM;    // Your existing token for integer literals
                        }

    /* Identifiers - Must be after keywords */
    ({ALPHA}|_)({ALPHA}|{DIGIT}|_)* {
                            yylval.tIdent = new Ident(std::string(yytext), lin, col);
                            col += yyleng;
                            return IDENT;
                        }

    /* Operators and Punctuation */
    ":="                    { int token_col = col; col += yyleng; return ASSIGN_OP; }
    "<>"                    { int token_col = col; col += yyleng; return NEQ_OP; }
    "<="                    { int token_col = col; col += yyleng; return LTE_OP; }
    ">="                    { int token_col = col; col += yyleng; return GTE_OP; }
    "+"                     { int token_col = col; col += yyleng; return '+'; }
    "-"                     { int token_col = col; col += yyleng; return '-'; }
    "*"                     { int token_col = col; col += yyleng; return '*'; }
    "/"                     { int token_col = col; col += yyleng; return '/'; } /* Real division */
    "="                     { int token_col = col; col += yyleng; return EQ_OP; } /* Equality */
    "<"                     { int token_col = col; col += yyleng; return LT_OP; }
    ">"                     { int token_col = col; col += yyleng; return GT_OP; }
    "("                     { int token_col = col; col += yyleng; return '('; }
    ")"                     { int token_col = col; col += yyleng; return ')'; }
    "["                     { int token_col = col; col += yyleng; return '['; }
    "]"                     { int token_col = col; col += yyleng; return ']'; }
    ":"                     { int token_col = col; col += yyleng; return ':'; }
    ";"                     { int token_col = col; col += yyleng; return ';'; }
    ","                     { int token_col = col; col += yyleng; return ','; }
    "."                     { int token_col = col; col += yyleng; return '.'; }


    .                       {
                            std::cerr << "Lexical Error: Unexpected character '" << *yytext
                                      << "' at line " << lin << ", column " << col << std::endl;
                            col += yyleng;
                            }
}

<ML_COMMENT>{
    "}"                 { col += yyleng; BEGIN(INITIAL); }
    [^{}\n\r]+          { col += yyleng; }
    \r\n|\n|\r         { lin++; col = 1; }
    "{"                 {
                          std::cerr << "Warning: Nested multi-line comment opening '{' found at line "
                                    << lin << ", column " << col
                                    << ". MiniPascal typically does not support true nesting." << std::endl;
                          col += yyleng;
                        }
    <<EOF>>             {
                          std::cerr << "Lexical Error: Unterminated multi-line comment that started at line "
                                    << comment_start_lin << ", column " << comment_start_col << "!" << std::endl;
                          BEGIN(INITIAL);
                          yyterminate();
                        }
}

%%
/* C code section */
/* %option noyywrap means yywrap() is not needed by Flex. */
/* Your main() is in program.cpp */